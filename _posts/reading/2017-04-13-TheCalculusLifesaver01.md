---
nav: blog
layout: post
title: "普林斯顿微积分读本 - 函数、图像和直线"
author: "王超"
tags:
  - '沟通的艺术'
  - 'Book'
  - '沟通'
  - '关系'
category:
  - 'Reading book'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.reading.name }}]({% link blog/reading/index.md %})/
{{ page.title }}

参考:[普林斯顿微积分读本](https://book.douban.com/subject/26899701/)

- [函数](#函数)
  - [区间表示法](#区间表示法)
  - [求定义域](#求定义域)
  - [利用图像求值域](#利用图像求值域)
  - [垂线校验](#垂线校验)
- [反函数](#反函数)
  - [水平线校验](#水平线校验)
  - [求反函数](#求反函数)
  - [限制定义域](#限制定义域)
  - [反函数的反函数](#反函数的反函数)
- [函数的复合](#函数的复合)
- [奇函数和偶函数](#奇函数和偶函数)
- [线性函数的图像](#线性函数的图像)
- [常见函数及其图像](#常见函数及其图像)


<span id="函数"></span>

## 函数

- **定义**：函数是将一个对象转化为另一个对象的规则. 起始对象称为`输入`, 来自称为`定义域`的集合. 返回对象称为`输出`, 来自称为`上域`的集合.
  - **例子**： f(x) = x^2 , 定义域为所有实数，那么 f 将 2 变为 4、将 -1/2 变为 1/4, 将 1 变为 1.
  - 补充基础：`质数`：`质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数的数称为质数。`
- 一个函数必须给每一个有效的输入指定唯一的输出.
- 函数 **值域**：是所有可能的输出所组成的集合.【函数转变其定义域中的一切, 每次转变一个对象; 转变后的对象所组成的集合称作`值域`】
- `值域`和`上域`的区别：`值域` 实际上是上域的一个子集. `上域` 是可能输出的集合, 而`值域`则是实际输出的集合.

<span id="区间表示法"></span>

### 区间表示法

- 闭区间:
    - [a, b] 是指从 a 到 b 端点间的所有实数, 包括 a 和 b. 所以 [a, b] 指的是所有使得 a ≤ x ≤ b 成立的 x 的集合.
    - [2, 5] 是所有介于 2 和 5 之间 (包括 2 和 5) 的实数的集合.
- 开区间:
    - (a, b) 是指介于 a 和 b 之间但不包括 a 和 b 的所有实数的集合. 所以, 如果 x 在区间 (a, b) 中, 我们就知道 a < x < b.
    - (2, 5) 是所有介于 2 和 5 之间 (不包括 2 和 5) 的实数的集合.
- 半开区间:
    - [a, b) 指的是介于 a 和 b 之间、包括 a 但不包括 b 的所有实数的集合; (a, b] 包括 b, 但不包括 a.
    - {x: a ≤ x < b } 和 {x: a < x ≤ b }
- 各种情况如下: `R` (所有实数)

![各种情况]({% link assets/thecalculuslifesaver/01_00.png %})

<span id="求定义域"></span>

### 求定义域

- 分数的分母不能是零.
- 不能取一个负数的平方根 (或四次根, 六次根, 等等).
- 不能取一个负数或零的对数.


<span id="利用图像求值域"></span>

### 利用图像求值域

- 函数 F , 指定其定义域为 `[-2, 1]`, 并且 `F (x) = x2` 在此定义域上

![利用图像求值域]({% link assets/thecalculuslifesaver/01_01.png %})

<span id="垂线校验"></span>

### 垂线校验

如果有某个图像并想知道它是否是函数的图像, 就看看是否有任何的垂线和图像相交多于一次.

如果是这样的话, 那它就不是函数的图像;

反之, 如果没有一条垂线和图像相交多于一次, 那么是函数的图像.

- 不是函数图像，违反垂线校验

![不是函数图像]({% link assets/thecalculuslifesaver/01_02.png %})

- 是函数图像，不违反垂线校验，整个圆的方程是 <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> = 9, 而上半圆的方程是 <img src="http://private.codecogs.com/gif.latex?y=\sqrt{9-x^2}" alt="y=\sqrt{9-x^2}">, 下半圆的方程是 <img src="http://private.codecogs.com/gif.latex?y=-\sqrt{9-x^2}" alt="y=-\sqrt{9-x^2}">. 

![是函数图像]({% link assets/thecalculuslifesaver/01_03.png %})


<span id="反函数"></span>

## 反函数

给定一个函数 `f` , 在 `f` 的值域中选择 `y`. 在理想状况下, 仅有一个 `x` 值满足 `f (x) = y`.

如果上述理想状况对于值域中的每一个 `y` 来说都成立, 那么就可以定义一个新的函数, 它将逆转变换.

从输出 `y` 出发, 这个新的函数发现一个且仅有一个输入 `x` 满足 `f (x) = y`.

这个新的函数称为 `f` 的反函数, 并写作 <code><em>f</em><sup>-1</sup></code>.

**数学语言总结:**

* 从一个函数 `f` 出发, 使得对于在 `f` 值域中的任意 `y`, 都只有唯一的 `x` 值满足 `f(x)= y`. 也就是说, 不同的输入对应不同的输出. 现在, 我们就来定义反函数 <code><em>f</em><sup>-1</sup></code>.
* <code><em>f</em><sup>-1</sup></code> 的定义域和 `f` 的值域相同.
* <code><em>f</em><sup>-1</sup></code> 的值域和 `f` 的定义域相同.
* <code><em>f</em><sup>-1</sup>(y)</code> 的值就是满足 `f(x) = y` 的 `x`. 所以, 如果 `f(x) = y`, 那么 <code><em>f</em><sup>-1</sup>(y) = x</code>.

变换 <code><em>f</em><sup>-1</sup></code> 就像是 `f` 的撤销按钮：如果你从 `x` 出发, 并通过函数 `f` 将它变换为 `y`, 那么你可以通过在 `y` 上的反函数 <code><em>f</em><sup>-1</sup></code> 来撤销这个变换的效果, 取回 `x`.

这会引发一些问题：你如何知道只有唯一的 `x` 值满足 `f(x) = y` 呢？如果是这样, 如何求得反函数呢, 其图像又是什么样子呢？如果不是这样, 你又如何挽救这一局面呢？

<span id="水平线校验"></span>

### 水平线校验

如果每一条水平线和一个函数的图像相交至多一次, 那么这个函数就有一个反函数. 

如果即使只有一条水平线和图像相交多于一次, 那么这个函数就没有反函数

**例如, 看一下 `f(x) = x3` 和 `g(x) = x2` 的图像.**

![水平线校验]({% link assets/thecalculuslifesaver/01_04.png %})

<span id="求反函数"></span>

### 求反函数

如果知道函数图像是什么样子的, 反函数的图像就会很容易画出来. 

基本思想是, 在图像上画一条 `y = x` 的直线, 然后将这条直线假想为一个双面的镜子. 

反函数就是原始函数的镜面反射. 如果 `f(x) = x3`, 那么 <code><em>f</em><sup>-1</sup>(y)</code> 的图像如下所示.

![求反函数]({% link assets/thecalculuslifesaver/01_05.png %})

<span id="限制定义域"></span>

### 限制定义域

如果水平线检验失败因而没有反函数, 即 对于相同的 `y` 有多个 `x` 值. 

解决方法: 除了这多个 `x` 值中的一个, 我们放弃所有其他值. 即 决定要保留哪一个 `x` 值, 然后放弃剩余的值. 即 `限制函数的定义域`.

![限制定义域]({% link assets/thecalculuslifesaver/01_06.png %})

以下图不是函数图。因为未通过垂直校验，即同一 `x` 对应多个个 `y`值.

![未限制定义域]({% link assets/thecalculuslifesaver/01_07.png %})

`垂直校验` 检验是否是函数图像， `水平校验` 则检验该函数是否有反函数（即同一`y`值是否有多个`x`值对应），如没有，是否可通过限制定义域来确定反函数.

<span id="反函数的反函数"></span>

### 反函数的反函数

如果 `f` 有反函数, 那么对于在 `f` 定义域中的所有 `x`, <code><em>f</em><sup>-1</sup>(f(x)) = x </code> 成立; 

同样, 对于在 `f` 值域当中的所有 `y`, 都有 <code>f(<em>f</em><sup>-1</sup>(y)) = y </code>. 

(`f` 的值域和 <code><em>f</em><sup>-1</sup></code> 的定义域相同, 所以对于 `f` 值域中的 `y`, 确实可以取到 <code><em>f</em><sup>-1</sup>(y)</code>, 不会导致任何曲解.)

即 反函数的反函数就是原始函数.

**总结：**

如果一个函数 `f` 的定义域可以被限制, 使得 `f` 有反函数 <code><em>f</em><sup>-1</sup></code>, 那么

* 对于 f 值域中的所有 y, 都有 <code><em>f</em><sup>-1</sup>(f(y)) = y </code> ; 但是
* <code><em>f</em><sup>-1</sup>(f(x))</code> 可能不等于 `x` ; 事实上, <code><em>f</em><sup>-1</sup>(f(x)) = x </code> 仅当 `x` 在限制的定义域中才成立.

<span id="函数的复合"></span>

### 函数的复合

即将一个复杂的函数拆解为多个简单的函数进行复合运用.

如: 考虑定义为 <code>f(x) = cos(<em>x</em><sup>2</sup>)</code> 的函数 `f`.  

* 令 <code>g(x) = <em>x</em><sup>2</sup></code>, `h(x) = cos(x)`. 
* 则 `f(x) = h(g(x))`， 也可表示为 `f = h ○ g` ， 圈表示 “与 …… 的复合”, 即 `f` 是 `g` 与 `h` 的复合.
* 即 `f` 是 `g` 与 `h` 的复合函数. 这里需要小心的是, 把 `h` 写在 `g` 的前面 (像平常一样从左向右读), 但计算时要先从 `g` 开始.

**练习:**

* 若 <code>g(x) = <em>2</em><sup>x</sup></code>, <code>h(x) = <em>5x</em><sup>4</sup></code>, <code>j(x) = 2x - 1</code>, 则函数 `f = g ○ h ○ j` 的表达式是什么？
* 假定开始于函数 <img src="http://private.codecogs.com/gif.latex?f(x%29=\frac{1}{\tan(5\log_2(x+3%29%29}." alt="f(x)=\frac{1}{\tan(5\log_2(x+3))}."> 如何将 `f` 分解为几个简单函数呢？

**另一个例子:**

将函数 `f` 和 `g(x) = x - a`(`a` 是常数) 进行复合. 对复合得到的新函数 `h(x) = f (x - a)`, 需要关注的是新函数 `y = h(x)` 和函数 `y = f(x)` 的图像是一样的, 只不过 `y = h(x)` 的函数图像向右平移了 `a` 个单位. 如果 `a` 是负的, 那么就是向左平移. (一种理解方式是, 向右平移 `-3` 个单位与向左平移 `3` 个单位是一样的. )

<code>y = <em>(x - 1)</em><sup>2</sup></code> 的图像 即使 函数 <code>y = <em>x</em><sup>2</sup></code> 的图像向右平移 `1` 个单位 ， 如图所示: 

![函数右移]({% link assets/thecalculuslifesaver/01_08.png %})


<span id="奇函数和偶函数"></span>

### 奇函数和偶函数

**偶函数:**  如果对 `f` 定义域里的所有 `x` 有 `f (-x) = f (x)`, 则 `f` 是偶函数. (这个等式对某些 `x` 值成立是不够的, 它必须对定义域里的所有 `x` 都成立.)

**奇函数:**  如果对 `f` 定义域里的所有 `x` 有 `f (-x) = -f (x)`, 则 `f` 是偶函数. (这个等式对某些 `x` 值成立是不够的, 它必须对定义域里的所有 `x` 都成立.)

一个函数可能是奇的, 可能是偶的, 也可能非奇非偶. 但有一个函数是 既奇又偶 的。

**既奇又偶函数：** `f(x) = 0 ` ，用 `f (-x) = f (x)` 减去 `f (-x) = -f (x)` 得到 `0 = 2f(x)`， 则 `f (x) = 0`

**判断一个函数是 奇函数 还是 偶函数:** 

**从图看:**

- 偶函数： 因 `f (x) = f (-x)`, 则 `y = f (x)` 的图像在 `x` 和 `-x` 坐标`上方`具有相同的高度, 且对所有的 `x` 都成立. 结论：**偶函数的图像关于 `y` 轴具有镜面对称性**. 所以当你画出偶函数的右半边图像后, 就可以通过将其图像关于 `y` 轴反射得到它的左半边图像. 例如：<code>y = <em>x</em><sup>2</sup></code>
- 奇函数： 因 `f (-x) = -f(x)`, 则 `y = f (x)` 的图像在 `x` 坐标 `上方` 和 `-x` 坐标`下方`具有相同的高度. 结论: **奇函数的图像关于`原点`有 180° 的点对称性**.
  - 意味着: 如果只有奇函数的右半边图像, 可按下面的方法得到其左半边的图像. 想象该曲线是浮在纸面上, 能够把它拿起来但不能改变它的形状. 并用大头针在原点处把曲线钉住 (回想一下, 奇函数若在 0 处有定义, 它必定通过原点), 然后将整个曲线旋转半圈, 这样就得到左半边图像的样子了.

**从表达式简化看:**

将每个 `x` 替换为 `(-x)` 并计算 `f (-x)`, 一定要记着给 `-x` 加上小括号, 然后化简结果. 如果得出了原始表达式 `f (x)`, `f` 就是偶的; 如果得到原始表达式的负值 `-f (x)`, `f` 就是奇的; 

例如函数 <code>f(x) = log<sub>5</sub>(2x<sup>6</sup> - 6x<sup>2</sup> + 3)</code> 代入`（-x）`简化后得到： <img src="http://private.codecogs.com/gif.latex?f(-x%29=\log_5(2(-x%29^6-6(-x%29^2+3%29=\log_5(2x^6-6x^2+3%29," alt="f(-x)=\log_5(2(-x)^6-6(-x)^2+3)=\log_5(2x^6-6x^2+3),"> ， 为原表达式，所以为 偶函数.


**证明 两个奇函数之积是偶函数:** 

定义有两个奇函数 `f` 和 `g`. 定义它们的乘积为 `h`, 即定义 `h(x) = f (x)g(x)`, 而任务是要证明 `h` 是偶的. 即需要证明 `h(-x) = h(x)`. 因 `f` 和 `g` 都是奇的, 所以得到 `f (-x) = -f (x)`, `g(-x) = -g(x)`. 

从 `h(-x)` 开始. 由于 `h` 是 `f` 和 `g` 的乘积, 有 `h(-x) = f (-x)g(-x)`. 再利用 `f` 和 `g` 的奇函数性质将等式右边表示为 `(-f (x))(-g (x))`, 负号提到前面消掉, 由此得到 `f (x)g(x)`, 而它当然等于 `h(x)`. 可以 (也应该) 把上述过程用数学式表示为：

<img src="http://private.codecogs.com/gif.latex?h(-x%29=f(-x%29g(-x%29=(-f(x%29%29(-g(x%29%29=f(x%29g(x%29=h(x%29." alt="h(-x)=f(-x)g(-x)=(-f(x))(-g(x))=f(x)g(x)=h(x).">

**练习证明：** 两偶函数之积仍为偶函数, 奇函数和偶函数之积是奇函数.

<span id="线性函数的图像"></span>

### 线性函数的图像

形如 `f (x) = mx + b` 的函数叫作线性函数. 如此命名原因很简单, 因为它们的图像是直线. 直线的斜率是 `m`. 设想一下, 此时此刻你就在这页纸中, 这条直线就像是座山, 你从左向右开始登山 。如图：

![线性函数]({% link assets/thecalculuslifesaver/01_09.png %})

如果像上图一样, 斜率 `m` 为正数, 那么你正在上山. `m` 越大, 这段上坡就越陡. 相反, 如果 `m` 为负数, 那么你正在下山. `m` 的数值越小 (即绝对值越大), 这段下坡也就越陡. 如果斜率为 `0`, 这段山路就是水平的, 你既不在上山, 也不在下山, 仅仅是在沿一条直线前行.

总结：

- 当 `m` 为 正数时，函数图像为 `正斜线` 。 当 `b` 为 正数时 ，函数向上移， 当 `b` 为 负数时， 函数 向下移.
- 当 `m` 为 负数时，函数图像为 `反斜线` 。 当 `b` 为 正数时 ，函数向上移， 当 `b` 为 负数时， 函数 向下移.

如果知道这条直线通过某一固定的点以及它的斜率, 那就能很容易地找到它的方程. 

**如果已知直线通过点<code>（x<sub>0</sub>, y<sub>0</sub>）</code>, 斜率为 `m` ， 则它的方程为 <code>y - y<sub>0</sub> = m(x - x<sub>0</sub>)</code>**

当不知道斜率，但知道它通过那两个点时，可通过下面的方法求出方程.

**如果一条直线通过点<code>（x<sub>1</sub>, y<sub>1</sub>）</code> 和 <code>(x<sub>2</sub>, y<sub>2</sub>)</code>, 则它的斜率等于![线性函数]({% link assets/thecalculuslifesaver/01_10.png %})**




<span id="常见函数及其图像"></span>

### 常见函数及其图像
