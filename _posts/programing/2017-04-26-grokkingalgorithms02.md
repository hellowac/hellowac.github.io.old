---
nav: blog
layout: post
title: "算法图解 - 选择排序"
author: "wangchao"
tags:
  - python
  - '算法'
  - '选择排序'
  - '图解算法'
category:
  - 'Programing Teach'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.programing.name }}]({% link blog/programing/index.md %})/
{{ page.title }}

参考:[算法图解](https://book.douban.com/subject/26979890/)


**数组和链表**

- 【存方便】：链表的优势在插入元素方面， 可灵活插入。不需要内存在一块。但是取比较麻烦.
- 【取方便】：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。 但是内存固定，不能扩展。

**数组和链表的时间复杂度：**

类型 | 数组 | 链表
-----| ---- | -----
读取 | O(1) | O(n)
插入 | O(n) | O(1)
删除 | O(n) | O(1)

O(n) : 线性时间
O(1) : 常量时间

**小练习：**

- 假设你要编写一个记账的应用程序。你每天都将所有的支出记录下来，并在月底统计支出，算算当月花了多少钱。因此，你执行的插入操作很多，但读取操作很少。该使用数组还是链表呢？
  - 应使用 链表. 【涉及大规模插入】

**插入和删除：**

删除元素时，链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移。

数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。
有两种访问方式：随机访问和顺序访问。

顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。

随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。数组和链表还被用来实现其他数据结构。

**小练习**

- 假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜单。服务员添加点菜单，而厨师取出点菜单并制作菜肴。这是一个点菜单队列：服务员在队尾添加点菜单，厨师取出队列开头的点菜单并制作菜肴。你使用数组还是链表来实现这个队列呢？（提示：链表擅长插入和删除，而数组擅长随机访问。在这个应用程序中，你要执行的是哪些操作呢？）
  - 显然使用链表. 因为只涉及插入和删除.
- 假设Facebook记录一系列用户名，每当有用户试图登录Facebook时，都查找其用户名，如果找到就允许用户登录。由于经常有用户登录Facebook，因此需要执行大量的用户名查找操作。假设Facebook使用二分查找算法，而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点，应使用数组还是链表来存储用户名呢？
  - 显然使用数组. 因为用户名不会随意删除的插入。并且这里需要随机访问。
- 经常有用户在Facebook注册。假设你已决定使用数组来存储用户名，在插入方面数组有何缺点呢？具体地说，在数组中添加新用户将出现什么情况？
  - 插入需要的时间很久。会出现用户等待过久的情况.
- 实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。假设Adit B在Facebook注册，而你需要将其加入前述数据结构中。因此，你访问数组的第一个元素，再访问该元素指向的链表，并将Adit B添加到这个链表末尾。现在假设你要查找Zakhir H。因此你访问第26个元素，再在它指向的链表（该链表包含所有以z打头的用户名）中查找Zakhir H。请问，相比于数组和链表，这种混合数据结构的查找和插入速度更慢还是更快？你不必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢。
  - 查找和插入更快.

**选择排序**

每次找出最大或最小的元素进行排序.

```python
def find_smallest(arr):
    """ 找出最小的元素 """
    smallest = arr[0]
    smallest_index = 0

    for i in range(1, len(arr)):
      if arr[i] < smallest:
        smallest_index = i
        smallest = arr[i]
    return smallest_index

def selectionSort(arr):
    """ 选择排序 """
    sorted_arr = []

    for i in range(len(arr)):
        smallest_index = find_smallest(arr)
        sorted_arr.append(arr.pop(smallest_index))
    return sorted_arr

my_arr = [10, 2, 3, 4, 8, 33, 1, 0]

print selectionSort(my_arr)  # [0, 1, 2, 3, 4, 8, 10, 33]
```

需要的总时间为 O(n × n)，即O(n2)。

随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。

既然如此，运行时间怎么还是O(n2)呢？并非每次都需要检查n个元素。

第一次需要检查n个元素，但随后检查的元素数依次为n - 1, n – 2, …, 2和1。

平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。

但大O表示法省略诸如1/2这样的常数，因此简单地写作O(n × n)或O(n2)。

**补充：和冒泡排序的区别**

冒泡排序（BubbleSort）的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。

即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。

至此第一趟结束，将最大的数放到了最后。

在第二趟：仍从第一对数开始比较 （因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个	数），将小数放前中，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟 结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。

如此下去，重复以上过程，直至最终完成排序。

选择排序 第一次从下标为0的开始下标为0的这个数与后面的n-1个进行比较；

找出最小或者最大的放在下标为0的这个位置；

第二次从下标为1的开始比较；

查询剩下的最大或者最小值；

放在下标为1的位置；

以此类推；直到排序完成
