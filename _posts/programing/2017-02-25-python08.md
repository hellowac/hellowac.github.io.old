---
nav: blog
layout: post
title: "python - 常用python3库"
author: "wangchao"
tags:
  - sqllite3
  - python
  - sqlAlchemy
  - tkinter
  - pyqt
  - elementTree
  - lxml
  - cherrypy
category:
  - 'Programing Teach'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.programing.name }}]({% link blog/programing/index.md %})/
{{ page.title }}

参考:[python3面向对象编程](https://book.douban.com/subject/26468916/)

- [数据库访问](#数据库访问)
    + [引入SQLAlchemy](#引入SQLAlchemy)
- [用户界面](#用户界面)
    + [TkInter](#TkInter)
    + [PyQt](#PyQt)
    + [一个GUI工具包](#一个GUI工具包)
- [XML](#XML)
    + [ElementTree](#ElementTree)
    + [Lxml](#Lxml)
- [CherryPy](#CherryPy)
    + [一个完整的web堆栈](#一个完整的web堆栈)
- [练习](#练习)

<span id="数据库访问"></span>

### 数据库访问

- python2: [sqlite3](https://docs.python.org/2.7/library/sqlite3.html)
- python3: [sqlite3](https://docs.python.org/3/library/sqlite3.html)

使用符合数据库API规范的DBAPI2. 任何遵循DBAPI2规范的数据库API都会有一个能返回Connection对象的connect函数，通过使用execute方法在这个连接里执行查询。

```python
# python3.5
import sqlite3

connection = sqlite3.connect('"mydb.db')
connection.execute(
    "CREATE TABLE IF NOT EXISTS "
    "pet (type, breed, gender, name)")
connection.execute("INSERT INTO pet VALUES("
    "'dog', 'spaniel', 'female', 'Esme')"
    )
connection.execute("INSERT INTO pet VALUES("
    "'cat', 'persian', 'male', 'Qscar')"
    )

results = connection.execute("SELECT breed, name"
    " from pet where type='dog'").fetchall()

for result in results:
    print(results)

connection.close()

# 输出:
[('spaniel', 'Esme')]
```

DBAPI2 是非常低层且难以使用的，在面向对象编程中，通常使用一个Object-Relational Manager或者叫做ORM来与数据库交互，这里使用 SQLAlchemy.

<span id="引入SQLAlchemy"></span>

#### 引入SQLAlchemy

官网: [sqlalchemy](http://www.sqlalchemy.org/)
文档: [sqlalchemy-doc](http://docs.sqlalchemy.org/en/rel_1_1/)

sqlAlchemy.create_engine函数提供了一个用于连接数据库的单一访问点.它需要大量的参数去定制化或者调整访问。最重要的为一个URL字符串,它定义了要连接的后台数据库种类,后台要连接的具体数据库，数据库名字，运行数据库的主机，还有一个用户名密码用于身份验证。基本形式为：driver://user:password@host/dbname

数据库里的每一个表通常都由一个单独的类代表.并且每一个类里的特殊属性都会映射到这个表的列.当我们要访问一个对象的属性时，我们会得到数据库值.并且当我们更新并保存这个对象时，数据库会被修改.

```python
import sqlalchemy as sqa
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Pet(Base):
    __tablename__ = "pet"
    id =sqa.Column(sqa.Integer,primary_key=True)
    type = sqa.Column(sqa.String(16))
    breed = sqa.Column(sqa.String(32))
    gender = sqa.Column(sqa.Enum('male',"female"))
    name = sqa.Column(sqa.String(64))

engine = sqa.create_engine('sqllite:///mydata.db')

Base.metadata.create_all(engine)        # 确保Base类的所有表都存在.

# 添加和查询对象
# 通常添加一个__init__方法会很有用.

pet = Pet()
pet.id = 1
pet.type = "dog"
pet.breed = "spaniel"
pet.gender = 'female'
pet.name = 'Esme'

# 创建session，将对象和数据库联系起来. session 就像数据库和对象之间的预备区域.
# 准备好把这个集合的变更保存到数据库的时候，可以通过commit()来提交它们,
# 如果出现问题,可以调用session.rollback()让所有变更消失.

Session = sqa.orm.sessionmaker(bind=engine)     # 获得一个特殊类Session. 传入要连的数据库引擎.
session = Session()                             # 每个会话都独立于其他会话.

# 基本依靠数据库处理，采用熟悉的规则，并且根据底层数据库的不同，规则可能也不同.

session.add(pet)

session.commit()

# 使用session.query()方法获取一个Query对象，
# 该方法接收代表要查询的表或者列的参数.
# 该Query对象的方法可以获得一连串的结果集。
# all(),返回表里的所有条目
# first(),返回第一个条目.
# one(), 返回唯一的条目，如果没有条目或者发现多个条目，会抛出一个异常.
# get(primary_key), 接收一个主键值返回匹配这个键值的对象.
# group_by()、order_by(),以及having()， 把相关的SQL语句添加到查询当中.
# filter_by(),使用关键字参数来查询这个会话.
# filter()， 使用更高级的SQL表达式查询.
# 例如:
print session.query(Pet).filter_by(name="Esme").one().name

# 输出:
Esme
```

__SQL表达式语言__

和接受关键字参数的filter_by不同,filter方法接收SQLAlchemy的SQL表达式中的值，这是一种更加强大的查询方式.它适用于对对象列的不同操作.它是一个`重载特殊`方法的应用.

例子: session.query(Pet).filter(Pet.name=="Esme")。
- 包含在filter查询里的表达式不是一个计算布尔值的典型相等比较. 
- 相反,它构造了一个合适的SQL语句,过滤方法会使用这个语句进行数据库查询。
- 这是通过`重写Pet.name列对象`的____eq____方法实现的. 
- 所以我们需要显示地声明用于相等比较的Pet.name对象. 
- 因此不能直接简单指定name,因为如果它是一个关键字参数，这会导致一个错误发生.

相关操作构造查询:
- == 相等
- != 不相等
- < 小于
- \> 大于
- <= 小于等于
- \>= 大于等于
- & 使用AND查询组合语句.
- \| 使用OR查询组合语句
- ～ 使用NOT来吧一个查询变成一个相反的查询.

SQLAlchemy 太强大... -_-。。。

<span id="用户界面"></span>

### 用户界面

图形应用程序: 总是依赖设计模式所提供的高水平的底层抽象.以至于很难看到对象的模式.

<span id="TkInter"></span>

#### TkInter

Python标准库自带的一个图形库.

官网文档: [Tcl/Tk-python3](https://docs.python.org/3/library/tkinter.html) 和 [Tcl/Tk-python2](https://docs.python.org/2/library/tkinter.html)
网友参考: [Python 下用 Tkinter 制作 GUI](http://pikipity.github.io/blog/python-tkinter.html)


```python
# python3.5
# 一个空白窗口程序
import tkinter

# 对于其他窗口部件，这是一个基本的容器。
class EmptyFrame(tkinter.Frame):
    pass

# 提供一个窗口来装载这个框架.
root = tkinter.Tk()
# mainloop来运行程序
EmptyFrame(master=root).mainloop()

# 一个可以交互的例子
import tkinter
import random

class DiceFrame(tkinter.Frame):
    def __init__(self,master):
        super().__init__(master)

        # 创建一个button对象,self是这个button的狂简
        # text表示显示在按钮上的字符串，
        # command为当一个按钮被点击时调用的函数.
        die = tkinter.Button(self,text="Roll!",command=self.roll)
        # 简单设置默认大小和位置,pack
        die.pack()

        # 特殊结构化的StringVar对象，只要调用set方法，就可以更新一个新的字符串。
        self.roll_result = tkinter.StringVar()
        label = tkinter.Label(self,textvariable=self.roll_result)
        label.pack()
        self.pack()

    def roll(self):
        self.roll_result.set(random.randint(1,6))

root = tkinter.Tk()

DiceFrame(master=root).mainloop()
```

所有图形化编程都是关于构建窗口部件，并且把命令关联到它们身上，一旦特定的事件发生，就会调用相应的命令.

可以通过pack方法进行定制窗口部件布局。支持的参数：

- expand:布尔值，决定如果父窗口缩放大小，是否窗口部件也要跟着缩放,即使超出了其预期大小.如果多个窗口部件设置了expand，那么会在它们中间划分额外的空间。
- fill: 可以设置none、x、y或者both的字符串值，用来指导窗口部件填满所有在特定方向分配给他的可用空间.
- anchor: 如果窗口部件没有设置填满它的空间，默认固定在center位置，其他值，n、e、s、w分别代表居上、居右、居低、居左。ne、se、sw、nw分别代表设置东北、东南、西南和西北4个角.
- ipadx和ipady: 整数值,提供了在窗口部件里面填充上下左右边缘大小的功能.有增大窗口部件大小的效果.
- padx 和 pady: 提供了填充窗口部件的边缘和它可用空间的值，它有在窗口部件和它的相邻部件之间放置空间.
- side: 使用left、right、top、bottom4个方向之一,沿着这个特定的方向放置窗口部件。通常情况下，在一个容器里的所有窗口部件都会被放在同一侧，混合它们会带来无法预料的效果，如果需要不止一行或者一列，可以把一个框架放置到另一个框架中.

```pypthon
# 布局实例
import tkinter

class PackFrame(tkinter.Frame):
    def __init__(self,master):
        super().__init__(master)

        button1 = tkinter.Button(self,text="expand fill")
        button1.pack(expand=True,fill="both",side="left")
        button2 = tkinter.Button(self,text="anchor ne pady")
        button2.pack(anchor="ne",pady=5,side="left")
        button3 = tkinter.Button(self,text="anchor se padx")
        button3.pack(anchor="se",pady=5,side="left")

class TwoPackFrames(tkinter.Frame):
    def __init__(self,master):
        super().__init__(master)

        button1 = tkinter.Button(self,text="ipadx")
        button1.pack(ipadx=215)
        packFrame1 = PackFrame(self)
        packFrame1.pack(side="bottom",anchor="e")
        packFrame2 = PackFrame(self)
        packFrame2.pack(side="bottom",anchor="w")
        self.pack()

root = tkinter.Tk()
TwoPackFrames(master=root).mainloop()
```

![TkInter_GUI]({% link assets/programingimg/TkInter_GUI.png %})

当设计复杂的接口，放置窗口框架时会比较单调，可以研究一下TkInter的网格窗口部件的布局风格.

<span id="PyQt"></span>

#### PyQt

流行的跨平台[Qt库](https://www.qt.io/cn/)的python绑定. 这是一个高级的库,某些方面是一个桌面应用程序框架，扩展支持了从Web浏览器到多媒体数据库的所有东西。

文档: [developers](https://www.qt.io/cn/developers/)

```python
# 基本实例
from PyQt4 import QtGui

app = QtGui.QApplication([])

class EmptyWidget(QtGui.QWidget):
    pass

window = EmptyWidget()
window.show()
# 相当于tkinter中的mainloop.
app.exec_()

# 一个石头剪刀布的游戏
from PyQt4 import QtGui
import random

app = QtGui.QApplication([])
choices = ["Rock","Paper","Scissors"]

class RockPaperScissorsWidget(QtGui.QWidget):
    def __init__(self):
        super(RockPaperScissorsWidget,self).__init__()
        rock = RPSButton("Rock",self)
        paper = RPSButton("Paper",self)
        scissors = RPSButton("Scissors",self)

        for button in (rock,paper,scissors):
            button.resize(100,100)

        # 绝对定位,不可随窗口调整大小.
        rock.move(0,0)
        paper.move(0,100)
        scissors.move(0,200)
        self.response = QtGui.QLabel("",self)     # 结果标签
        self.response.setGeometry(110,0,200,300)

class RPSButton(QtGui.QPushButton):
    # 重写鼠标单击事件.
    def mousePressEvent(self,event):
        computer_choice = random.choice(choices)
        user_choice = self.text()

        comp_idx = choices.index(computer_choice)
        user_idx = choices.index(user_choice)

        message = {
        0: 'Tied',
        1: 'Computer Wins',
        2: 'You win'
        }[(comp_idx - user_idx + 3) % 3]

        self.parent().response.setText("You chose {0}<br/>"
            "Computer chose {1}<br/>"
            "{2}".format(user_choice,computer_choice,message))

window = RockPaperScissorsWidget()
window.show()
app.exec_()
```

![Qt4_GUI]({% link assets/programingimg/Qt4_GUI.png %})

<span id="一个GUI工具包"></span>

#### 一个GUI工具包

其他两个非常流行的包 [PyGTK](http://www.pygtk.org/) 和 [wxPython](https://wxpython.org/)

wxpython 是一个非常先进的跨平台系统,有基于当前运行的操作系统平台显示本地窗口部件的优势. 可以使wxPython程序“无缝”地融入操作系统感觉和视觉.

对于一个给定的任务，应该选哪个？这取决于个人爱好，需要每个都尝试一段时间，来决定哪一个提供给自己最好的编程范式.

<span id="XML"></span>

### XML

```python
```

<span id="ElementTree"></span>

#### ElementTree

```python
```

<span id="CherryPy"></span>

### CherryPy

```python
```

<span id="一个完整的web堆栈"></span>

#### 一个完整的web堆栈

```python
```

<span id="练习"></span>

### 练习

```python
```


