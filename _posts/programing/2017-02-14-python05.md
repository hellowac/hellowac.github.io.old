---
nav: blog
layout: post
title: "python - 设计模式二"
author: "wangchao"
tags:
  - python
  - '设计模式'
category:
  - 'Programing Teach'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.programing.name }}]({% link blog/programing/index.md %})/
{{ page.title }}

参考:[python3面向对象编程](https://book.douban.com/subject/26468916/)

* [适配器模式](#适配器模式)
* [外观模式](#外观模式)
* [享元模式](#享元模式)
* [命令模式](#命令模式)
* [抽象工厂模式](#抽象工厂模式)
* [组合模式](#组合模式)
* [练习]()

<span id="适配器模式"></span>

### 适配器模式

被设计用于与现有代码进行交互

适配器对象位于两个不同的接口之间，对两个接口进行即时转换。

比如将参数转化为另一种格式，重新排列参数的顺序，调用名称不同的方法或提供默认参数.

UML图:

![适配器模式]({% link assets/programingimg/UML_adapter_parttern.png %})

```python
# 假设 有 以 格式“YYYY-MM-DD” 接收一个字符串的日期 的 类，并通过日期来计算一个人的年龄
class AgeCalculator:
    def __init__(self,birthday):
        self.year,self.month,self.day = ( int(x) for x in birthday.split('-'))

    def calculate_age(self,date):
        year,month,day = ( int(x) for x in date.split('-'))

        age = year - self.year
        if (month,year) < (self.month,self.day):
            age -= 1

        return age
# 输出
>>> person = AgeCalculator('1990-02-01')
>>> today = '2017-09-12'
>>> person.calculate_age(today)
27

# 适配器 接收内置的datetime对象.
import datetime

class DateAgeAdapter:
    def _str_date(self,date):
        return date.strftime("%Y-%m-%d")

    def __init__(self,birthday):
        birthday = self._str_date(birthday)
        self.calculator = AgeCalculator(birthday)

    def get_age(self,date):
        date = self._str_date(date)
        return self.calculator.calculate_age(date)
# 输出
>>> date = datetime.datetime(1975, 6, 14)
>>> today = date.today()
>>> today
2017-02-14 15:56:52.474361
>>> person = DateAgeAdapter(date)
>>> person.get_age(today)
41
```

创建一个类作为适配器是实现一种模式的常用方式.

单还有其他许多方法可以做到这一点.

比如 继承 datetime 模块中的 date 类 并添加split()函数 ，这样它的工作原理就与原来的AgeCalculator类相同.

```python
import datetime
class AgeableDate(datetime.date):
    def split(self,char):
        return self.year,self.month,self.day

# 输出
>>> bad = AgeableDate(1975,6,14)
>>> today = AgeableDate.today()
>>> today
2017-02-14
>>> person = AgeCalculator(bad)
>>> person.calculate_age(today)
41
```
但在 这个 特定实例 中 ，添加 split 方法 是 一个 愚蠢的错误，将会导致难以维护，因为我们会很快忘记为什么需要将split方法添加到date类中.

<span id="外观模式"></span>

### 外观模式

```python

```

<span id="享元模式"></span>

### 享元模式

```python

```

<span id="命令模式"></span>

### 命令模式

```python

```

<span id="抽象工厂模式"></span>

### 抽象工厂模式

```python

```

<span id="组合模式"></span>

### 组合模式

```python

```

<span id="练习"></span>

### 练习

```python

```




