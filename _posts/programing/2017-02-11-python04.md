---
nav: blog
layout: post
title: "python - 设计模式一"
author: "wangchao"
tags:
  - python
  - '设计模式'
category:
  - 'Programing Teach'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.programing.name }}]({% link blog/programing/index.md %})/
{{ page.title }}

参考:[python3面向对象编程](https://book.douban.com/subject/26468916/)

* [设计模式](#设计模式)
* [装饰器模式](#装饰器模式)
    * [装饰器实例](#装饰器实例)
    * [python装饰器](#python装饰器)
* [观察者模式](#观察者模式)
    * [观察者实例](#观察者实例)
* [策略模式](#策略模式)
    * [策略实例](#策略实例)
    * [python策略模式](#python策略模式)
* [状态模式](#状态模式)
    * [状态实例](#状态实例)
    * [与策略模式对比](#与策略模式对比)
* [单件模式](#单件模式)
    * [实现方式](#实现方式)
    * [模块变量模仿单件](#模块变量模仿单件)
* [模版模式](#模版模式)
    * [模版实例](#模版实例)


<span id="设计模式"></span>

### 设计模式

设计模式: 提出一组以特定方式相互作用的对象来解决某个普遍性问题.

参考设计事故: [魁北克大桥](http://blog.sina.com.cn/s/blog_71fc9ce00102v29v.html)

<span id="装饰器模式"></span>

### 装饰器模式

将一个提供核心功能的对象和其他可以改变这个功能的对象“包裹”在一起.（装饰对象的接口与核心对象相同）

* __用途:__ (适用场景)
    * 增强一个组件向另一个组件发送数据时的响应能力.
    * 支持多种可选行为 (可以代替多重继承)

<span id="装饰器实例"></span>

#### 装饰器实例

网络编程实例:

python2 [socket](https://docs.python.org/2.7/library/socket.html)

python3 [socket](https://docs.python.org/3/library/socket.html)

__未装饰版本:__

```python
# 服务器端
import socket

def respond(client):
    # response = input("Enter a value:")    # python3
    response = raw_input("Enter a value:")  # python2

    # client.send(bytes(response,'utf8'))   # python3

    client.send(bytes(response))            # python2
    client.close()

server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.bind(('localhost',2401))
server.listen(1)

try :
    while True:
        client,addr = server.accept()
        respond(client)
finally:
    server.close()

# 客户端
import socket

client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
client.connect(('localhost',2401))

print("Received:{0}".format(client.recv(1024)))
client.close()

# 在两个窗口中分别运行,先运行服务端,然后运行客户端，随后服务端会要求输入字符.
# 服务器端:
$ python server.py
Enter a value:haha

# 客户端:
$ python client.py
Received:haha
```

__logging 装饰器__

```python
import socket

class LogSocket:
    def __init__(self,socket):
        self.socket = socket

    def send(self,data):
        print('Sending {0} to {1}'.format(
            data,self.socket.getpeername()[0]))
        self.socket.send(data)

    def close(self):
        self.socket.close()

def respond(client):
    # response = input("Enter a value:")        # python3
    response = raw_input("Enter a value:")      # python2

    # client.send(bytes(response,'utf8'))       # python3

    client.send(bytes(response))                # python2
    client.close()

server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.bind(('localhost',2401))
server.listen(1)

try :
    while True:
        client,addr = server.accept()
        # respond(client)

        respond(LogSocket(client))      # 应用装饰器

finally:
    server.close()

# 再次运行
# 服务器端
$ python rubbishsql.py
Enter a value:decorator
Sending decorator to 127.0.0.1

# 客户端
$ python client.py
Received:decorator
```

__gzip装饰器:__

```python
import gzip
from io import BytesIO

class GzipSocket:
    def __init__(self,socket):
        self.socket = socket

    def send(self,data):
        """ 将发送的数据进行压缩
        """
        buf = BytesIO()
        zipfile = gzip.GzipFile(fileobj=buf,mode="w")
        zipfile.write(data)
        zipfile.close()
        self.socket.send(buf.getvalue())

    def close(self):
        self.socket.close()

# 使用时:

client, addr = server.accept()

# 需要发送日志
if log_send:
    client = LogSocket(client)

# 将数据进行压缩
if client.getpeername()[0] in compress_hosts:
    client = GzipSocket(client)

respond(client)
```

<span id="python装饰器"></span>

#### python装饰器

返回函数的函数

```python
import time

def log_calls(func):
    """ 接收一个函数作为参数
    """
    def wrapper(*args, **kwargs):
        """ 在调用原始函数之前进行一些其他额外操作,并替换原函数
        """
        now = time.time()
        print("Calling {0} with {1} and {2}".format(
            func.__name__,args,kwargs))

        return_value = func(*args, **kwargs)

        print("Executed {0} in {1}ms".format(
            func.__name__,time.time() - now))

        return return_value

    return wrapper          #返回替换原始函数的新函数   

def test1(a,b,c):
    print("\t test1 called")

def test2(a,b):
    print("\t test2 called")

def test3(a,b):
    print("\t test3 called")
    time.sleep(1)

test1 = log_calls(test1)        # 装饰test1
test2 = log_calls(test2)        # 装饰test2
test3 = log_calls(test3)        # 装饰test3

test1(1,2,3)
test2(4,b=5)
test3(6,7)

# 输出
Calling test1 with (1, 2, 3) and {}
     test1 called
Executed test1 in 3.504753112792969e-05ms
Calling test2 with (4,) and {'b': 5}
     test2 called
Executed test2 in 1.0013580322265625e-05ms
Calling test3 with (6, 7) and {}
     test3 called
Executed test3 in 1.0016839504241943ms
```

__@符号装饰器语法:__

* 适用于我们自己写的方法.如果装饰我们自己没写过的方法.还是用之前的方法.

```python
import time

def log_calls(func):
    """ 接收一个函数作为参数
    """
    def wrapper(*args, **kwargs):
        """ 在调用原始函数之前进行一些其他额外操作,并替换原函数
        """
        now = time.time()
        print("Calling {0} with {1} and {2}".format(
            func.__name__,args,kwargs))

        return_value = func(*args, **kwargs)

        print("Executed {0} in {1}ms".format(
            func.__name__,time.time() - now))

        return return_value

    return wrapper          #返回替换原始函数的新函数   

@log_calls
def test1(a,b,c):
    print("\t test1 called")

@log_calls
def test2(a,b):
    print("\t test2 called")

@log_calls
def test3(a,b):
    print("\t test3 called")
    time.sleep(1)

test1(1,2,3)
test2(4,b=5)
test3(6,7)
```

__思考:__

* 装饰器可以被创建为可调用的对象，而不仅仅是返回新函数的函数.
* 类也可以被装饰，此时装饰器会返回一个新的类，而不是新的函数.
* 装饰器还可以接收参数来进行定制.

<span id="观察者模式"></span>

### 观察者模式

应用于 `状态监测` 和 `事件处理` 等场景. 

该模式 确保 一个 `核心对象` 可以由 一组未知 并 可能正在扩展的`“观察者” 对象`来监控.

一旦核心对象的某个值发生变化，它便通过调用update()函数来让`所有观察者对象`知道情况发生了变化.

各个对象在`核心对象`发生变化时，有可能会负责处理不同的任务；`核心对象`不知道也不关心这些任务是什么.

通常`观察者`也同样不知道、不关心其他的`观察者`正在做什么。

__特别适用于:__

* 冗余系统备份【存到多个数据库，远程主机】

<span id="观察者实例"></span>

#### 观察者实例

库存监控:

```python
class Inventory:
    def __init__(self):
        self.observers = []
        self._product = None
        self._quantity = 0

    def attach(self,observer):
        """ 添加观察者
        """
        self.observers.append(observer)

    @property
    def product(self):
        return self._product

    @product.setter
    def product(self,value):
        self._product = value
        self._update_observers()    # 通知观察者

    @property
    def quantity(self):
        return self._quantity

    @quantity.setter
    def quantity(self,value):
        self._quantity = value
        self._update_observers()    # 通知观察者

    def _update_observers(self):
        """遍历注册的观察者,并执行观察对象
        """
        for observer in self.observers:
            observer()

class ConsoleObserver:
    """ 控制台观察者
    """
    def __init__(self,inventory):
        self.inventory = inventory

    def __call__(self):
        """ 特殊方法:实现实例自身调用
        """
        print(self.inventory.product)
        print(self.inventory.quantity)

# 测试:
>>> i = Inventory()
>>> c = ConsoleObserver(i)      # 观察谁
>>> i.attach(c)                 # 注册观察者.
>>> i.product = "Widget"
Widget
0
>>> i.quantity = 5 
Widget
5

# 其他观察者
class StoreObserver:
    """ 存储观察者
    """
    def __init__(self,inventory):
        self.inventory = inventory

    def __call__(self):
        """ 特殊方法:实现实例自身调用
        """
        self.store()

    def store(self):
        
        print("Store product:{0}".format(self.inventory.product))
        print("Store quantity:{0}".format(self.inventory.quantity))

# 测试
>>> i = Inventory()
>>> c = ConsoleObserver(i)      # 观察谁
>>> s = StoreObserver(i)
>>> i.attach(c)                 # 注册观察者.
>>> s.attach(s)
>>> i.product = "Widget"
Widget
0
Store product:Widget
Store quantity:0
>>> i.quantity = 5 
Widget
5
Store product:Widget
Store quantity:5
```

<span id="策略模式"></span>

### 策略模式

面向对象编程的抽象模式

实现了不同对象采用不同解决方案.

代码可以在运行时动态选择其中最恰当的实现.

<span id="策略实例"></span>

#### 策略实例

根据屏幕的大小使用指定的策略处理图像,并返回一个新的对象.

```python
from pygame import image
from pygame.transform import scale
from pygame import Surface

class TiledStrategy:
    """ 根据输入图像的高度和宽度进行循环并将其重复叠加到新图像的适当位置
    """
    def make_background(self,img_file,desktop_size):
        in_img = image.load(img_file)
        out_img = Surface(desktop_size)
        for x in range((out_img.get_width() // in_img.get_width()) + 1) :
            for y in range((out_img.get_height() // in_img.get_height()) + 1) :
                out_img.blit(in_img, (in_img.get_width() * x, in_img.get_height() * y))

        return out_img

class CenteredStrategy:
    """ 计算出需要留出多少空间给4个边缘来使图像居中
    """
    def make_background(self,img_file,desktop_size):
        in_img = image.load(img_file)
        out_img = Surface(desktop_size)
        out_img.fill((0,0,0))
        left = (out_img.get_width() - in_img.get_width()) / 2
        top = (out_img.get_height() - in_img.get_width()) / 2
        out_img.blit(in_img,(left,top))
        return out_img

class ScaledStrategy:
    """ 简单的将图像调整成需要输出需要的尺寸(忽略长宽比)
    """
    def make_background(self,img_file,desktop_size):
        in_img = image.load(img_file)
        return scale(in_img,desktop_size)

# 这里每个类只有一个函数，其实可以使用__call__特殊函数，使的对象本身可以被调用.
# 这里也可以创建一组 一级函数(顶级函数) 并传递他们 来 代替 类.
```

如果不使用策略模式，则需要在一个方法中需要大量的if判断语句进行选择，当想要添加一个新的策略时，就不得不使这个函数变的更加笨重.

<span id="python策略模式"></span>

#### python策略模式

python的一级函数( 顶级函数 ) 允许我们可以用更直接的方式来实现这一策略.

<span id="状态模式"></span>

### 状态模式

对象显而易见地处于一个特定状态，同时某些活动可能驱动它转变到另一个不同的状态

需要一个`管理者类`或`上下文类`为状态转换提供一个接口。在类内部,包含一个指向当前状态的指针.

每个状态都知道可以转换哪些其他状态并如何根据调用的操作转换到这个状态.

上下文类(管理者类)维护当前状态,并且转发操作到状态类.

状态类对其他调用上下文的对象而言通常是隐藏的. 它的行为就像一个黑盒子,在内部执行状态管理.

<span id="状态实例"></span>

#### 状态实例

__XML 解析实例:__

```python

```

<span id="与策略模式对比"></span>

#### 与策略模式对比

```python

```

<span id="单件模式"></span>

### 单件模式

```python

```

<span id="实现方式"></span>

#### 实现方式

```python

```

<span id="模块变量模仿单件"></span>

#### 模块变量模仿单件

```python

```

<span id="模版模式"></span>

### 模版模式

```python

```

<span id="模版实例"></span>

#### 模版实例

```python

```