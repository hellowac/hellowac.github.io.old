---
nav: blog
layout: post
title: "算法图解 - 狄克斯特拉算法"
author: "wangchao"
tags:
  - python
  - '算法'
  - '广度优先搜索'
  - '图解算法'
category:
  - 'Programing Teach'
show: true
---

[{{ site.nav.home.name }}]({% link index.md %})/
[{{ site.nav.blog.name }}]({% link blog/index.md %})/
[{{ site.nav.blog.subnav.programing.name }}]({% link blog/programing/index.md %})/
{{ page.title }}

参考:[算法图解](https://book.douban.com/subject/26979890/)

**加权图**

提高或降低某些边的权重。

例如百度的，公交搜索时的最短时间.【最快时间的路径】

**狄克斯特拉算法**

只能处理非负数加权的图.

包含的步骤：

- 找出“最便宜”的节点，即可在最短时间内到达的节点。
- 更新该节点的`邻居`的开销
- 重复这个过程，直到对图中的每个节点都这样做了。
- 计算最终路径。

一. **找出“便宜的节点”，列表，对于还不知道的终点，设置为无穷大。**

**节点** | **耗时**
-----|-----
A | 6
B | 2
终点 | None

二. **计算经节点B前往其各个邻居所需的时间。**

发现经由 节点B 到 节点A 所需时间为 5 ， 更新表。

**节点** | **耗时**
-----|-----
A | 5
B | 2
终点 | 7

对于节点B的邻居，如果找到前往它的更短路径，就更新其开销。

此处找到：

- 前往节点A的更短路径（时间从6分钟缩短到5分钟）；
- 前往终点的更短路径（时间从无穷大缩短到7分钟）。

三. 重复之前的步骤.

**重复第一步**：找出可在最短时间内前往的节点。你对节点B执行了第二步，除节点B外，可在最短时间内前往终点的节点是节点A。
**重复第二步**：更新 节点A 的所有 邻居 的开销。发现 经由 节点A 到终点 的时间 为 1， 因此比较两者时间 5+1 < 2 + 5 . 更新表.

**节点** | **耗时**
-----|-----
A | 5
B | 2
终点 | 6

对每个节点都运行了狄克斯特拉算法（无需对终点这样做）。现在知道：

- 前往节点B需要2分钟；
- 前往节点A需要5分钟；
- 前往终点需要6分钟。

四. 最后一步,计算最终路径

广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。

在狄克斯特拉算法中，给每段边都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。

**术语：**

狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。

带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）

要计算非加权图中的最短路径，可使用广度优先搜索。

要计算加权图中的最短路径，可使用`狄克斯特拉算法`。图还可能有环，而环类似右面这样： A -> B -> C -> A

`无向图`意味着两个节点彼此指向对方，其实就是环！

在`无向图`中，每条边都是一个环。`狄克斯特拉算法` 只适用于`有向无环图`（directed acyclic graph，DAG）。


**实例：想拿一本乐谱换架钢琴。权重如图所示**

![狄克斯特拉算法事例]({% link assets/programingimg/狄克斯特拉算法事例.png %})

表格：

**节点** | **权重**
-----|------
黑胶唱片 | 5
海报 | 0
吉他 | None 【无穷大，随后更新】
架子鼓 | None【无穷大，随后更新】
钢琴 | None【无穷大，随后更新】

在执行狄克斯特拉算法的过程中，将不断更新这个表。

为计算最终路径，还需在这个表中添加表示父节点的列。

**节点** | **父节点**
-----|--------
黑胶唱片 | 乐谱
海报 | 乐谱
吉他 | -- [未知，稍后更新最“便宜”的父节点]
架子鼓 | -- [未知，稍后更新最“便宜”的父节点]
钢琴 | -- [未知，稍后更新最“便宜”的父节点]

第一步： 找出最便宜的节点。 创建表：

**父节点** | **节点** | **权重**
---------|-----------|------
乐谱 | 黑胶唱片 | 5
乐谱 | 海报 | 0

**狄克斯特拉算法背后的关键理念：**`找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！`

第二步：计算前往该节点的各个邻居的开销。 更新表：

**父节点** | **节点** | **权重**
---------|-----------|------
乐谱 | 黑胶唱片 | 5
乐谱 | 海报 | 0
**海报** | `吉他` | None -> 0 + 30 -> 30
**海报** | `架子鼓` | None -> 0 + 35 -> 35
--[未知的`最便宜`的父节点] | 钢琴 | None 未知

**再次执行第一步**：下一个最便宜的节点是黑胶唱片 ——需要额外支付5美元。

**再次执行第二步**：更新黑胶唱片的各个邻居的开销。 更新表. 【更新比较贵的吉他和架子鼓的父节点为较便宜的黑胶唱片】

**父节点** | **节点** | **权重**
---------|-----------|------
乐谱 | 黑胶唱片 | 5
乐谱 | 海报 | 0
**黑胶唱片**  | `吉他` | None -> 5 + 15 -> 20
**黑胶唱片**  | `架子鼓` | None -> 5 + 20 -> 25
--[未知的`最便宜`的父节点] | 钢琴 | None 未知

更新了架子鼓和吉他的开销！这意味着经“黑胶唱片”前往“架子鼓”和“吉他”的开销更低，因此将这些乐器的父节点改为黑胶唱片

最后一步：计算吉他的架子鼓的邻居的开销，并更新最便宜的父节点.

**父节点** | **节点** | **权重**
---------|-----------|------
乐谱 | 黑胶唱片 | 5
乐谱 | 海报 | 0
**黑胶唱片**  | `吉他` | None -> 5 + 15 -> 20
**黑胶唱片**  | `架子鼓` | None -> 5 + 20 -> 25
**吉他** | `钢琴` | None -> 20 + 20 -> 40 【此路径不是最便宜，应被更新,但为了说明，保留】
**架子鼓** | `钢琴` | None -> 25 + 10 -> 35 【此路径最便宜，更新吉他父节点为架子鼓.】

此时最终的最便宜的表格应是：

**父节点** | **节点**
---------|----------
乐谱 | 黑胶唱片
乐谱 | 海报
**黑胶唱片**  | `吉他`
**黑胶唱片**  | `架子鼓`
**架子鼓** | `钢琴`

此时只需沿着钢琴的父节点向上延伸就能找到完整路径 ： 钢琴 -> 架子鼓 -> 黑胶唱片 -> 乐谱 【最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。】

**负权边**

边的权重为负的情况.

**实现**

![狄克斯特拉算法事例2]({% link assets/programingimg/狄克斯特拉算法事例2.png %})

三个散列表的样子:

![狄克斯特拉算法事例3]({% link assets/programingimg/狄克斯特拉算法事例3.png %})

```python
# 编写解决这个问题的代码，需要三个散列表。图、权重、子父节点。
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

# 添加其他节点及其邻居。
graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {}  # 终点没有任何邻居

# 获取start节点的所有邻居
neighbours = graph["start"].keys()

# 用一个散列表来存储每个节点的开销。
infinity = float("inf")  # Python中表示无穷大
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

# 一个存储父节点的散列表：
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None

# 需要一个数组，用于记录处理过的节点，因为对于同一个节点，你不用处理多次。
processed = []

def suan_fa():
    node = find_lowest_cost_node(costs) # 在未处理的节点中找出开销最小的节点
    while node is not None:  # 这个while循环在所有节点都被处理过后结束
        cost = costs[node]   # 获取当前节点权重
        neighbors = graph[node]  # 邻居们
        for n in neighbors.keys():  # 遍历当前节点的所有邻居
            new_cost = cost + neighbors[n]  # 下个节点的权重.
            if costs[n] > new_cost:  # 如果经当前节点前往该邻居更近，
                costs[n] = new_cost  # 就更新该邻居的开销
                parents[n] = node  # 同时将该邻居的父节点设置为当前节点
        processed.append(node)  # 将当前节点标记为处理过
        node = find_lowest_cost_node(costs)  # 找出接下来要处理的节点，并循环

def find_lowest_cost_node(costs):
    lowest_cost = float("inf")  # float类型无穷大.
    lowest_cost_node = None
    for node in costs:  # 遍历所有的节点
        cost = costs[node]
        if cost < lowest_cost and node not in processed:  # 如果当前节点的开销更低且未处理过，
            lowest_cost = cost  # 就将其视为开销最低的节点
            lowest_cost_node = node
    return lowest_cost_node

# 疑问： 不需要考虑节点顺序么？
```

**小结：**

- 度优先搜索用于在非加权图中查找最短路径。
- 狄克斯特拉算法用于在加权图中查找最短路径。
- 仅当权重为正时狄克斯特拉算法才管用。
- 如果图中包含负权边，请使用贝尔曼-福德算法。
